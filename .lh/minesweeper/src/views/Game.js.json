{
    "sourceFile": "minesweeper/src/views/Game.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 21,
            "patches": [
                {
                    "date": 1731359246990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731360254221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,105 @@\n+import React, { useState, useEffect } from 'react';\n+import { useParams } from 'react-router-dom';\n+import Cell from '../components/Cell';\n+\n+function Game() {\n+  const { difficulty } = useParams();\n+  const [grid, setGrid] = useState([]);\n+  const [isGameOver, setIsGameOver] = useState(false);\n+  const [hasWon, setHasWon] = useState(false);\n+\n+  const config = {\n+    easy: { size: 8, mines: 10 },\n+    medium: { size: 16, mines: 40 },\n+    hard: { size: 30, mines: 99 },\n+  }[difficulty] || { size: 8, mines: 10 };\n+\n+  useEffect(() => {\n+    resetGame();\n+  }, [difficulty]);\n+\n+  function initializeGrid() {\n+    const emptyGrid = Array(config.size).fill(null).map(() => Array(config.size).fill({\n+      isRevealed: false, isMine: false, adjacentMines: 0,\n+    }));\n+\n+    placeMines(emptyGrid);\n+    setGrid(emptyGrid);\n+  }\n+\n+  function placeMines(grid) {\n+    let minesPlaced = 0;\n+    while (minesPlaced < config.mines) {\n+      const row = Math.floor(Math.random() * config.size);\n+      const col = Math.floor(Math.random() * config.size);\n+      if (!grid[row][col].isMine) {\n+        grid[row][col].isMine = true;\n+        updateAdjacentCounts(grid, row, col);\n+        minesPlaced++;\n+      }\n+    }\n+  }\n+\n+  function updateAdjacentCounts(grid, row, col) {\n+    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n+      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n+        if (!grid[r][c].isMine) {\n+          grid[r][c].adjacentMines++;\n+        }\n+      }\n+    }\n+  }\n+\n+  function handleClick(row, col) {\n+    if (isGameOver || grid[row][col].isRevealed) return;\n+\n+    if (grid[row][col].isMine) {\n+      setIsGameOver(true);\n+      alert(\"Game over! You lost!\");\n+      return;\n+    }\n+\n+    const newGrid = [...grid];\n+    newGrid[row][col].isRevealed = true;\n+    setGrid(newGrid);\n+\n+    if (checkWin(newGrid)) {\n+      setHasWon(true);\n+      alert(\"Game over! You won!\");\n+    }\n+  }\n+\n+  function checkWin(grid) {\n+    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n+  }\n+\n+  function resetGame() {\n+    setIsGameOver(false);\n+    setHasWon(false);\n+    initializeGrid();\n+  }\n+\n+  return (\n+    <div>\n+      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n+      <button onClick={resetGame}>Reset</button>\n+      <div className=\"board\">\n+        {grid.map((row, rIndex) => (\n+          <div key={rIndex} className=\"row\">\n+            {row.map((cell, cIndex) => (\n+              <Cell\n+                key={`${rIndex}-${cIndex}`}\n+                isRevealed={cell.isRevealed}\n+                isMine={cell.isMine}\n+                adjacentMines={cell.adjacentMines}\n+                onClick={() => handleClick(rIndex, cIndex)}\n+              />\n+            ))}\n+          </div>\n+        ))}\n+      </div>\n+    </div>\n+  );\n+}\n+\n+export default Game;\n"
                },
                {
                    "date": 1731360306198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,109 +102,4 @@\n   );\n }\n \n export default Game;\n-import React, { useState, useEffect } from 'react';\n-import { useParams } from 'react-router-dom';\n-import Cell from '../components/Cell';\n-\n-function Game() {\n-  const { difficulty } = useParams();\n-  const [grid, setGrid] = useState([]);\n-  const [isGameOver, setIsGameOver] = useState(false);\n-  const [hasWon, setHasWon] = useState(false);\n-\n-  const config = {\n-    easy: { size: 8, mines: 10 },\n-    medium: { size: 16, mines: 40 },\n-    hard: { size: 30, mines: 99 },\n-  }[difficulty] || { size: 8, mines: 10 };\n-\n-  useEffect(() => {\n-    resetGame();\n-  }, [difficulty]);\n-\n-  function initializeGrid() {\n-    const emptyGrid = Array(config.size).fill(null).map(() => Array(config.size).fill({\n-      isRevealed: false, isMine: false, adjacentMines: 0,\n-    }));\n-\n-    placeMines(emptyGrid);\n-    setGrid(emptyGrid);\n-  }\n-\n-  function placeMines(grid) {\n-    let minesPlaced = 0;\n-    while (minesPlaced < config.mines) {\n-      const row = Math.floor(Math.random() * config.size);\n-      const col = Math.floor(Math.random() * config.size);\n-      if (!grid[row][col].isMine) {\n-        grid[row][col].isMine = true;\n-        updateAdjacentCounts(grid, row, col);\n-        minesPlaced++;\n-      }\n-    }\n-  }\n-\n-  function updateAdjacentCounts(grid, row, col) {\n-    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n-      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n-        if (!grid[r][c].isMine) {\n-          grid[r][c].adjacentMines++;\n-        }\n-      }\n-    }\n-  }\n-\n-  function handleClick(row, col) {\n-    if (isGameOver || grid[row][col].isRevealed) return;\n-\n-    if (grid[row][col].isMine) {\n-      setIsGameOver(true);\n-      alert(\"Game over! You lost!\");\n-      return;\n-    }\n-\n-    const newGrid = [...grid];\n-    newGrid[row][col].isRevealed = true;\n-    setGrid(newGrid);\n-\n-    if (checkWin(newGrid)) {\n-      setHasWon(true);\n-      alert(\"Game over! You won!\");\n-    }\n-  }\n-\n-  function checkWin(grid) {\n-    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n-  }\n-\n-  function resetGame() {\n-    setIsGameOver(false);\n-    setHasWon(false);\n-    initializeGrid();\n-  }\n-\n-  return (\n-    <div>\n-      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n-      <button onClick={resetGame}>Reset</button>\n-      <div className=\"board\">\n-        {grid.map((row, rIndex) => (\n-          <div key={rIndex} className=\"row\">\n-            {row.map((cell, cIndex) => (\n-              <Cell\n-                key={`${rIndex}-${cIndex}`}\n-                isRevealed={cell.isRevealed}\n-                isMine={cell.isMine}\n-                adjacentMines={cell.adjacentMines}\n-                onClick={() => handleClick(rIndex, cIndex)}\n-              />\n-            ))}\n-          </div>\n-        ))}\n-      </div>\n-    </div>\n-  );\n-}\n-\n-export default Game;\n"
                },
                {
                    "date": 1731361238269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from '../components/Cell';\n+import Cell from './components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361325068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from './components/Cell';\n+import Cell from '../Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361353085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from '../Cell';\n+import Cell from '../../components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361393877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from '../../components/Cell';\n+import Cell from '/components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361438834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from '/components/Cell';\n+import Cell from './components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361544306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from './components/Cell';\n+import Cell from './src./components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731361596196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useState, useEffect } from 'react';\n import { useParams } from 'react-router-dom';\n-import Cell from './src./components/Cell';\n+import Cell from '../components/Cell';\n \n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n"
                },
                {
                    "date": 1731362331762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,79 +26,19 @@\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n   }\n \n-  function placeMines(grid) {\n-    let minesPlaced = 0;\n-    while (minesPlaced < config.mines) {\n-      const row = Math.floor(Math.random() * config.size);\n-      const col = Math.floor(Math.random() * config.size);\n-      if (!grid[row][col].isMine) {\n-        grid[row][col].isMine = true;\n-        updateAdjacentCounts(grid, row, col);\n-        minesPlaced++;\n-      }\n-    }\n-  }\n-\n-  function updateAdjacentCounts(grid, row, col) {\n-    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n-      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n-        if (!grid[r][c].isMine) {\n-          grid[r][c].adjacentMines++;\n-        }\n-      }\n-    }\n-  }\n-\n-  function handleClick(row, col) {\n-    if (isGameOver || grid[row][col].isRevealed) return;\n-\n-    if (grid[row][col].isMine) {\n-      setIsGameOver(true);\n-      alert(\"Game over! You lost!\");\n-      return;\n-    }\n-\n-    const newGrid = [...grid];\n-    newGrid[row][col].isRevealed = true;\n-    setGrid(newGrid);\n-\n-    if (checkWin(newGrid)) {\n-      setHasWon(true);\n-      alert(\"Game over! You won!\");\n-    }\n-  }\n-\n-  function checkWin(grid) {\n-    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n-  }\n-\n   function resetGame() {\n     setIsGameOver(false);\n     setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n     <div>\n-      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n+      <h1>{hasWon ? \"You Won!\" : isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n       <button onClick={resetGame}>Reset</button>\n-      <div className=\"board\">\n-        {grid.map((row, rIndex) => (\n-          <div key={rIndex} className=\"row\">\n-            {row.map((cell, cIndex) => (\n-              <Cell\n-                key={`${rIndex}-${cIndex}`}\n-                isRevealed={cell.isRevealed}\n-                isMine={cell.isMine}\n-                adjacentMines={cell.adjacentMines}\n-                onClick={() => handleClick(rIndex, cIndex)}\n-              />\n-            ))}\n-          </div>\n-        ))}\n-      </div>\n+      {/* Render the game board here */}\n     </div>\n   );\n }\n \n"
                },
                {
                    "date": 1731362391196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,19 +26,80 @@\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n   }\n \n+  // Define the placeMines function here\n+  function placeMines(grid) {\n+    let minesPlaced = 0;\n+    while (minesPlaced < config.mines) {\n+      const row = Math.floor(Math.random() * config.size);\n+      const col = Math.floor(Math.random() * config.size);\n+      if (!grid[row][col].isMine) {\n+        grid[row][col].isMine = true;\n+        updateAdjacentCounts(grid, row, col);\n+        minesPlaced++;\n+      }\n+    }\n+  }\n+\n+  function updateAdjacentCounts(grid, row, col) {\n+    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n+      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n+        if (!grid[r][c].isMine) {\n+          grid[r][c].adjacentMines++;\n+        }\n+      }\n+    }\n+  }\n+\n+  function handleClick(row, col) {\n+    if (isGameOver || grid[row][col].isRevealed) return;\n+\n+    if (grid[row][col].isMine) {\n+      setIsGameOver(true);\n+      alert(\"Game over! You lost!\");\n+      return;\n+    }\n+\n+    const newGrid = [...grid];\n+    newGrid[row][col].isRevealed = true;\n+    setGrid(newGrid);\n+\n+    if (checkWin(newGrid)) {\n+      setHasWon(true);\n+      alert(\"Game over! You won!\");\n+    }\n+  }\n+\n+  function checkWin(grid) {\n+    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n+  }\n+\n   function resetGame() {\n     setIsGameOver(false);\n     setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n     <div>\n-      <h1>{hasWon ? \"You Won!\" : isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n+      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n       <button onClick={resetGame}>Reset</button>\n-      {/* Render the game board here */}\n+      <div className=\"board\">\n+        {grid.map((row, rIndex) => (\n+          <div key={rIndex} className=\"row\">\n+            {row.map((cell, cIndex) => (\n+              <Cell\n+                key={`${rIndex}-${cIndex}`}\n+                isRevealed={cell.isRevealed}\n+                isMine={cell.isMine}\n+                adjacentMines={cell.adjacentMines}\n+                onClick={() => handleClick(rIndex, cIndex)}\n+              />\n+            ))}\n+          </div>\n+        ))}\n+      </div>\n     </div>\n   );\n }\n \n"
                },
                {
                    "date": 1731362607109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,29 +18,33 @@\n     resetGame();\n   }, [difficulty]);\n \n   function initializeGrid() {\n+    console.log(\"Initializing grid...\");\n     const emptyGrid = Array(config.size).fill(null).map(() => Array(config.size).fill({\n       isRevealed: false, isMine: false, adjacentMines: 0,\n     }));\n-\n+  \n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n+    console.log(\"Grid initialized\");\n   }\n-\n-  // Define the placeMines function here\n+  \n   function placeMines(grid) {\n+    console.log(\"Placing mines...\");\n     let minesPlaced = 0;\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n       if (!grid[row][col].isMine) {\n-        grid[row][col].isMine = true;\n+        grid[row][col] = { ...grid[row][col], isMine: true }; // Avoid mutation\n         updateAdjacentCounts(grid, row, col);\n         minesPlaced++;\n       }\n     }\n+    console.log(\"Mines placed\");\n   }\n+  \n \n   function updateAdjacentCounts(grid, row, col) {\n     for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n       for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n"
                },
                {
                    "date": 1731362943929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,33 +18,31 @@\n     resetGame();\n   }, [difficulty]);\n \n   function initializeGrid() {\n-    console.log(\"Initializing grid...\");\n-    const emptyGrid = Array(config.size).fill(null).map(() => Array(config.size).fill({\n-      isRevealed: false, isMine: false, adjacentMines: 0,\n-    }));\n-  \n+    const emptyGrid = Array.from({ length: config.size }, () =>\n+      Array.from({ length: config.size }, () => ({\n+        isRevealed: false,\n+        isMine: false,\n+        adjacentMines: 0,\n+      }))\n+    );\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n-    console.log(\"Grid initialized\");\n   }\n-  \n+\n   function placeMines(grid) {\n-    console.log(\"Placing mines...\");\n     let minesPlaced = 0;\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n       if (!grid[row][col].isMine) {\n-        grid[row][col] = { ...grid[row][col], isMine: true }; // Avoid mutation\n+        grid[row][col] = { ...grid[row][col], isMine: true };\n         updateAdjacentCounts(grid, row, col);\n         minesPlaced++;\n       }\n     }\n-    console.log(\"Mines placed\");\n   }\n-  \n \n   function updateAdjacentCounts(grid, row, col) {\n     for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n       for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n@@ -74,9 +72,9 @@\n     }\n   }\n \n   function checkWin(grid) {\n-    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n+    return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n   }\n \n   function resetGame() {\n     setIsGameOver(false);\n@@ -85,11 +83,16 @@\n   }\n \n   return (\n     <div>\n-      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n+      <h1>{hasWon ? \"You Won!\" : isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n       <button onClick={resetGame}>Reset</button>\n-      <div className=\"board\">\n+      <div\n+        className={`board ${difficulty} ${window.innerWidth > 1024 ? 'large-screen' : ''}`}\n+        style={{\n+          gridTemplateColumns: `repeat(${config.size}, 1fr)`\n+        }}\n+      >\n         {grid.map((row, rIndex) => (\n           <div key={rIndex} className=\"row\">\n             {row.map((cell, cIndex) => (\n               <Cell\n"
                },
                {
                    "date": 1731363502475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,8 @@\n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n   const [isGameOver, setIsGameOver] = useState(false);\n-  const [hasWon, setHasWon] = useState(false);\n \n   const config = {\n     easy: { size: 8, mines: 10 },\n     medium: { size: 16, mines: 40 },\n@@ -55,57 +54,53 @@\n \n   function handleClick(row, col) {\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n-    if (grid[row][col].isMine) {\n+    const newGrid = [...grid];\n+    if (newGrid[row][col].isMine) {\n       setIsGameOver(true);\n-      alert(\"Game over! You lost!\");\n+      alert(\"Game over! You hit a bomb!\");\n+      revealAllMines(newGrid);\n+      setGrid(newGrid);\n       return;\n     }\n \n-    const newGrid = [...grid];\n     newGrid[row][col].isRevealed = true;\n     setGrid(newGrid);\n-\n-    if (checkWin(newGrid)) {\n-      setHasWon(true);\n-      alert(\"Game over! You won!\");\n-    }\n   }\n \n-  function checkWin(grid) {\n-    return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n+  function revealAllMines(grid) {\n+    // Reveals all mines on the board when the game is over\n+    grid.forEach(row => {\n+      row.forEach(cell => {\n+        if (cell.isMine) {\n+          cell.isRevealed = true;\n+        }\n+      });\n+    });\n   }\n \n   function resetGame() {\n     setIsGameOver(false);\n-    setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n     <div>\n-      <h1>{hasWon ? \"You Won!\" : isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n+      <h1>{isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n       <button onClick={resetGame}>Reset</button>\n-      <div\n-        className={`board ${difficulty} ${window.innerWidth > 1024 ? 'large-screen' : ''}`}\n-        style={{\n-          gridTemplateColumns: `repeat(${config.size}, 1fr)`\n-        }}\n-      >\n-        {grid.map((row, rIndex) => (\n-          <div key={rIndex} className=\"row\">\n-            {row.map((cell, cIndex) => (\n-              <Cell\n-                key={`${rIndex}-${cIndex}`}\n-                isRevealed={cell.isRevealed}\n-                isMine={cell.isMine}\n-                adjacentMines={cell.adjacentMines}\n-                onClick={() => handleClick(rIndex, cIndex)}\n-              />\n-            ))}\n-          </div>\n-        ))}\n+      <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n+        {grid.map((row, rIndex) =>\n+          row.map((cell, cIndex) => (\n+            <Cell\n+              key={`${rIndex}-${cIndex}`}\n+              isRevealed={cell.isRevealed}\n+              isMine={cell.isMine}\n+              adjacentMines={cell.adjacentMines}\n+              onClick={() => handleClick(rIndex, cIndex)}\n+            />\n+          ))\n+        )}\n       </div>\n     </div>\n   );\n }\n"
                },
                {
                    "date": 1731363744589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,44 +5,55 @@\n function Game() {\n   const { difficulty } = useParams();\n   const [grid, setGrid] = useState([]);\n   const [isGameOver, setIsGameOver] = useState(false);\n+  const [hasWon, setHasWon] = useState(false);\n \n+  // Sets up the size of the grid and the number of mines based on the selected difficulty level\n   const config = {\n     easy: { size: 8, mines: 10 },\n     medium: { size: 16, mines: 40 },\n     hard: { size: 30, mines: 99 },\n-  }[difficulty] || { size: 8, mines: 10 };\n+  }[difficulty] || { size: 8, mines: 10 }; // Default to easy if something goes wrong\n \n+  // Reset the game every time the difficulty changes\n   useEffect(() => {\n     resetGame();\n   }, [difficulty]);\n \n+  // Sets up a new grid and adds mines\n   function initializeGrid() {\n+    // Create a blank grid with cells set to \"not revealed\" and no mines\n     const emptyGrid = Array.from({ length: config.size }, () =>\n       Array.from({ length: config.size }, () => ({\n         isRevealed: false,\n         isMine: false,\n         adjacentMines: 0,\n       }))\n     );\n+\n+    // Add mines to the grid\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n   }\n \n+  // Randomly add mines to cells in the grid\n   function placeMines(grid) {\n     let minesPlaced = 0;\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n+\n+      // Only place a mine if there's not already one there\n       if (!grid[row][col].isMine) {\n         grid[row][col] = { ...grid[row][col], isMine: true };\n-        updateAdjacentCounts(grid, row, col);\n+        updateAdjacentCounts(grid, row, col); // Update nearby cells to track this new mine\n         minesPlaced++;\n       }\n     }\n   }\n \n+  // Increments the \"adjacentMines\" count for cells around a newly placed mine\n   function updateAdjacentCounts(grid, row, col) {\n     for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n       for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n         if (!grid[r][c].isMine) {\n@@ -51,26 +62,61 @@\n       }\n     }\n   }\n \n+  // Handles what happens when a player clicks a cell\n   function handleClick(row, col) {\n+    // Do nothing if the game is already over or if the cell is already revealed\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n     const newGrid = [...grid];\n+\n+    // If the cell is a mine, game over!\n     if (newGrid[row][col].isMine) {\n       setIsGameOver(true);\n       alert(\"Game over! You hit a bomb!\");\n-      revealAllMines(newGrid);\n+      revealAllMines(newGrid); // Show all mines\n       setGrid(newGrid);\n       return;\n     }\n \n-    newGrid[row][col].isRevealed = true;\n+    // If it's safe, start revealing cells recursively\n+    revealCell(newGrid, row, col);\n     setGrid(newGrid);\n+\n+    // Check if all non-mine cells are revealed, meaning the player wins\n+    if (checkWin(newGrid)) {\n+      setHasWon(true);\n+      alert(\"Congratulations! You won!\");\n+    }\n   }\n \n+  // Recursive function to reveal cells with 0 adjacent mines\n+  function revealCell(grid, row, col) {\n+    if (\n+      row < 0 || col < 0 || row >= config.size || col >= config.size || \n+      grid[row][col].isRevealed || grid[row][col].isMine\n+    ) {\n+      return; // Stop if out of bounds, already revealed, or a mine\n+    }\n+\n+    grid[row][col].isRevealed = true;\n+\n+    // If the cell has no adjacent mines, keep revealing nearby cells\n+    if (grid[row][col].adjacentMines === 0) {\n+      revealCell(grid, row - 1, col);\n+      revealCell(grid, row + 1, col);\n+      revealCell(grid, row, col - 1);\n+      revealCell(grid, row, col + 1);\n+      revealCell(grid, row - 1, col - 1);\n+      revealCell(grid, row - 1, col + 1);\n+      revealCell(grid, row + 1, col - 1);\n+      revealCell(grid, row + 1, col + 1);\n+    }\n+  }\n+\n+  // Shows all mines when the game is over\n   function revealAllMines(grid) {\n-    // Reveals all mines on the board when the game is over\n     grid.forEach(row => {\n       row.forEach(cell => {\n         if (cell.isMine) {\n           cell.isRevealed = true;\n@@ -78,16 +124,23 @@\n       });\n     });\n   }\n \n+  // Checks if the player has revealed all non-mine cells\n+  function checkWin(grid) {\n+    return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n+  }\n+\n+  // Resets the game by reinitializing the grid and resetting the game state\n   function resetGame() {\n     setIsGameOver(false);\n+    setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n     <div>\n-      <h1>{isGameOver ? \"Game Over\" : \"Minesweeper\"}</h1>\n+      <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n       <button onClick={resetGame}>Reset</button>\n       <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n         {grid.map((row, rIndex) =>\n           row.map((cell, cIndex) => (\n"
                },
                {
                    "date": 1731363889904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,53 +7,45 @@\n   const [grid, setGrid] = useState([]);\n   const [isGameOver, setIsGameOver] = useState(false);\n   const [hasWon, setHasWon] = useState(false);\n \n-  // Sets up the size of the grid and the number of mines based on the selected difficulty level\n   const config = {\n     easy: { size: 8, mines: 10 },\n     medium: { size: 16, mines: 40 },\n     hard: { size: 30, mines: 99 },\n-  }[difficulty] || { size: 8, mines: 10 }; // Default to easy if something goes wrong\n+  }[difficulty] || { size: 8, mines: 10 };\n \n-  // Reset the game every time the difficulty changes\n   useEffect(() => {\n     resetGame();\n   }, [difficulty]);\n \n-  // Sets up a new grid and adds mines\n   function initializeGrid() {\n-    // Create a blank grid with cells set to \"not revealed\" and no mines\n     const emptyGrid = Array.from({ length: config.size }, () =>\n       Array.from({ length: config.size }, () => ({\n         isRevealed: false,\n         isMine: false,\n         adjacentMines: 0,\n       }))\n     );\n \n-    // Add mines to the grid\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n   }\n \n-  // Randomly add mines to cells in the grid\n   function placeMines(grid) {\n     let minesPlaced = 0;\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n \n-      // Only place a mine if there's not already one there\n       if (!grid[row][col].isMine) {\n         grid[row][col] = { ...grid[row][col], isMine: true };\n-        updateAdjacentCounts(grid, row, col); // Update nearby cells to track this new mine\n+        updateAdjacentCounts(grid, row, col);\n         minesPlaced++;\n       }\n     }\n   }\n \n-  // Increments the \"adjacentMines\" count for cells around a newly placed mine\n   function updateAdjacentCounts(grid, row, col) {\n     for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n       for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n         if (!grid[r][c].isMine) {\n@@ -62,47 +54,40 @@\n       }\n     }\n   }\n \n-  // Handles what happens when a player clicks a cell\n   function handleClick(row, col) {\n-    // Do nothing if the game is already over or if the cell is already revealed\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n     const newGrid = [...grid];\n \n-    // If the cell is a mine, game over!\n     if (newGrid[row][col].isMine) {\n       setIsGameOver(true);\n       alert(\"Game over! You hit a bomb!\");\n-      revealAllMines(newGrid); // Show all mines\n+      revealAllMines(newGrid);\n       setGrid(newGrid);\n       return;\n     }\n \n-    // If it's safe, start revealing cells recursively\n     revealCell(newGrid, row, col);\n     setGrid(newGrid);\n \n-    // Check if all non-mine cells are revealed, meaning the player wins\n     if (checkWin(newGrid)) {\n       setHasWon(true);\n       alert(\"Congratulations! You won!\");\n     }\n   }\n \n-  // Recursive function to reveal cells with 0 adjacent mines\n   function revealCell(grid, row, col) {\n     if (\n       row < 0 || col < 0 || row >= config.size || col >= config.size || \n       grid[row][col].isRevealed || grid[row][col].isMine\n     ) {\n-      return; // Stop if out of bounds, already revealed, or a mine\n+      return;\n     }\n \n     grid[row][col].isRevealed = true;\n \n-    // If the cell has no adjacent mines, keep revealing nearby cells\n     if (grid[row][col].adjacentMines === 0) {\n       revealCell(grid, row - 1, col);\n       revealCell(grid, row + 1, col);\n       revealCell(grid, row, col - 1);\n@@ -113,9 +98,8 @@\n       revealCell(grid, row + 1, col + 1);\n     }\n   }\n \n-  // Shows all mines when the game is over\n   function revealAllMines(grid) {\n     grid.forEach(row => {\n       row.forEach(cell => {\n         if (cell.isMine) {\n@@ -124,24 +108,24 @@\n       });\n     });\n   }\n \n-  // Checks if the player has revealed all non-mine cells\n   function checkWin(grid) {\n     return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n   }\n \n-  // Resets the game by reinitializing the grid and resetting the game state\n   function resetGame() {\n     setIsGameOver(false);\n     setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n     <div>\n-      <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n-      <button onClick={resetGame}>Reset</button>\n+      <div className=\"header\">\n+        <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n+        <button onClick={resetGame}>Reset</button>\n+      </div>\n       <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n         {grid.map((row, rIndex) =>\n           row.map((cell, cIndex) => (\n             <Cell\n"
                },
                {
                    "date": 1731364204136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,45 +7,53 @@\n   const [grid, setGrid] = useState([]);\n   const [isGameOver, setIsGameOver] = useState(false);\n   const [hasWon, setHasWon] = useState(false);\n \n+  // Sets up the size of the grid and the number of mines based on the selected difficulty level\n   const config = {\n     easy: { size: 8, mines: 10 },\n     medium: { size: 16, mines: 40 },\n     hard: { size: 30, mines: 99 },\n-  }[difficulty] || { size: 8, mines: 10 };\n+  }[difficulty] || { size: 8, mines: 10 }; // Default to easy if something goes wrong\n \n+  // Reset the game every time the difficulty changes\n   useEffect(() => {\n     resetGame();\n   }, [difficulty]);\n \n+  // Sets up a new grid and adds mines\n   function initializeGrid() {\n+    // Create a blank grid with cells set to \"not revealed\" and no mines\n     const emptyGrid = Array.from({ length: config.size }, () =>\n       Array.from({ length: config.size }, () => ({\n         isRevealed: false,\n         isMine: false,\n         adjacentMines: 0,\n       }))\n     );\n \n+    // Add mines to the grid\n     placeMines(emptyGrid);\n     setGrid(emptyGrid);\n   }\n \n+  // Randomly add mines to cells in the grid\n   function placeMines(grid) {\n     let minesPlaced = 0;\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n \n+      // Only place a mine if there's not already one there\n       if (!grid[row][col].isMine) {\n         grid[row][col] = { ...grid[row][col], isMine: true };\n-        updateAdjacentCounts(grid, row, col);\n+        updateAdjacentCounts(grid, row, col); // Update nearby cells to track this new mine\n         minesPlaced++;\n       }\n     }\n   }\n \n+  // Increments the \"adjacentMines\" count for cells around a newly placed mine\n   function updateAdjacentCounts(grid, row, col) {\n     for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n       for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n         if (!grid[r][c].isMine) {\n@@ -54,40 +62,47 @@\n       }\n     }\n   }\n \n+  // Handles what happens when a player clicks a cell\n   function handleClick(row, col) {\n+    // Do nothing if the game is already over or if the cell is already revealed\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n     const newGrid = [...grid];\n \n+    // If the cell is a mine, game over!\n     if (newGrid[row][col].isMine) {\n       setIsGameOver(true);\n       alert(\"Game over! You hit a bomb!\");\n-      revealAllMines(newGrid);\n+      revealAllMines(newGrid); // Show all mines\n       setGrid(newGrid);\n       return;\n     }\n \n+    // If it's safe, start revealing cells recursively\n     revealCell(newGrid, row, col);\n     setGrid(newGrid);\n \n+    // Check if all non-mine cells are revealed, meaning the player wins\n     if (checkWin(newGrid)) {\n       setHasWon(true);\n       alert(\"Congratulations! You won!\");\n     }\n   }\n \n+  // Recursive function to reveal cells with 0 adjacent mines\n   function revealCell(grid, row, col) {\n     if (\n       row < 0 || col < 0 || row >= config.size || col >= config.size || \n       grid[row][col].isRevealed || grid[row][col].isMine\n     ) {\n-      return;\n+      return; // Stop if out of bounds, already revealed, or a mine\n     }\n \n     grid[row][col].isRevealed = true;\n \n+    // If the cell has no adjacent mines, keep revealing nearby cells\n     if (grid[row][col].adjacentMines === 0) {\n       revealCell(grid, row - 1, col);\n       revealCell(grid, row + 1, col);\n       revealCell(grid, row, col - 1);\n@@ -98,8 +113,9 @@\n       revealCell(grid, row + 1, col + 1);\n     }\n   }\n \n+  // Shows all mines when the game is over\n   function revealAllMines(grid) {\n     grid.forEach(row => {\n       row.forEach(cell => {\n         if (cell.isMine) {\n@@ -108,36 +124,40 @@\n       });\n     });\n   }\n \n+  // Checks if the player has revealed all non-mine cells\n   function checkWin(grid) {\n     return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n   }\n \n+  // Resets the game by reinitializing the grid and resetting the game state\n   function resetGame() {\n     setIsGameOver(false);\n     setHasWon(false);\n     initializeGrid();\n   }\n \n   return (\n-    <div>\n+    <div className=\"game-container\">\n       <div className=\"header\">\n-        <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n+        <h1>Minesweeper</h1>\n         <button onClick={resetGame}>Reset</button>\n       </div>\n-      <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n-        {grid.map((row, rIndex) =>\n-          row.map((cell, cIndex) => (\n-            <Cell\n-              key={`${rIndex}-${cIndex}`}\n-              isRevealed={cell.isRevealed}\n-              isMine={cell.isMine}\n-              adjacentMines={cell.adjacentMines}\n-              onClick={() => handleClick(rIndex, cIndex)}\n-            />\n-          ))\n-        )}\n+      <div className=\"board\">\n+        {grid.map((row, rIndex) => (\n+          <div key={rIndex} className=\"row\">\n+            {row.map((cell, cIndex) => (\n+              <Cell\n+                key={`${rIndex}-${cIndex}`}\n+                isRevealed={cell.isRevealed}\n+                isMine={cell.isMine}\n+                adjacentMines={cell.adjacentMines}\n+                onClick={() => handleClick(rIndex, cIndex)}\n+              />\n+            ))}\n+          </div>\n+        ))}\n       </div>\n     </div>\n   );\n }\n"
                },
                {
                    "date": 1731364258852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -137,28 +137,24 @@\n     initializeGrid();\n   }\n \n   return (\n-    <div className=\"game-container\">\n-      <div className=\"header\">\n-        <h1>Minesweeper</h1>\n-        <button onClick={resetGame}>Reset</button>\n+    <div>\n+      <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n+      <button onClick={resetGame}>Reset</button>\n+      <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n+        {grid.map((row, rIndex) =>\n+          row.map((cell, cIndex) => (\n+            <Cell\n+              key={`${rIndex}-${cIndex}`}\n+              isRevealed={cell.isRevealed}\n+              isMine={cell.isMine}\n+              adjacentMines={cell.adjacentMines}\n+              onClick={() => handleClick(rIndex, cIndex)}\n+            />\n+          ))\n+        )}\n       </div>\n-      <div className=\"board\">\n-        {grid.map((row, rIndex) => (\n-          <div key={rIndex} className=\"row\">\n-            {row.map((cell, cIndex) => (\n-              <Cell\n-                key={`${rIndex}-${cIndex}`}\n-                isRevealed={cell.isRevealed}\n-                isMine={cell.isMine}\n-                adjacentMines={cell.adjacentMines}\n-                onClick={() => handleClick(rIndex, cIndex)}\n-              />\n-            ))}\n-          </div>\n-        ))}\n-      </div>\n     </div>\n   );\n }\n \n"
                },
                {
                    "date": 1731365549245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,210 @@\n+import React, { useState, useEffect } from 'react';\n+import { useParams } from 'react-router-dom';\n+import Cell from '../components/Cell';\n+\n+function Game() {\n+  const { difficulty } = useParams();\n+\n+  // Define game states and configurations\n+  const [grid, setGrid] = useState([]);\n+  const [isGameOver, setIsGameOver] = useState(false);\n+  const [hasWon, setHasWon] = useState(false);\n+  const [isFirstClick, setIsFirstClick] = useState(true);\n+  const [flagCount, setFlagCount] = useState(0);\n+\n+  // Configuration for different difficulties\n+  const config = {\n+    easy: { size: 8, mines: 10 },\n+    medium: { size: 16, mines: 40 },\n+    hard: { size: 30, mines: 99 },\n+  }[difficulty] || { size: 8, mines: 10 };\n+\n+  // Reset the game whenever the difficulty changes\n+  useEffect(() => {\n+    resetGame();\n+  }, [difficulty]);\n+\n+  // Load saved game state if available\n+  useEffect(() => {\n+    const savedState = JSON.parse(localStorage.getItem(\"minesweeperGameState\"));\n+    if (savedState && savedState.difficulty === difficulty) {\n+      setGrid(savedState.grid);\n+      setIsGameOver(savedState.isGameOver);\n+      setHasWon(savedState.hasWon);\n+      setIsFirstClick(savedState.isFirstClick);\n+      setFlagCount(savedState.flagCount);\n+    } else {\n+      resetGame();\n+    }\n+  }, [difficulty]);\n+\n+  // Save game state to local storage on state changes\n+  useEffect(() => {\n+    const gameState = { grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty };\n+    localStorage.setItem(\"minesweeperGameState\", JSON.stringify(gameState));\n+  }, [grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty]);\n+\n+  // Initialize a new grid and set up mines\n+  function initializeGrid() {\n+    // Create an empty grid with no mines and cells not revealed\n+    const emptyGrid = Array.from({ length: config.size }, () =>\n+      Array.from({ length: config.size }, () => ({\n+        isRevealed: false,\n+        isMine: false,\n+        isFlagged: false,\n+        adjacentMines: 0,\n+      }))\n+    );\n+\n+    setGrid(emptyGrid);\n+    setFlagCount(config.mines);\n+  }\n+\n+  // Place mines on the grid, avoiding the first click position\n+  function placeMinesAvoidingFirstClick(grid, firstRow, firstCol) {\n+    let minesPlaced = 0;\n+    while (minesPlaced < config.mines) {\n+      const row = Math.floor(Math.random() * config.size);\n+      const col = Math.floor(Math.random() * config.size);\n+\n+      if (\n+        (row !== firstRow || col !== firstCol) &&\n+        !grid[row][col].isMine\n+      ) {\n+        grid[row][col] = { ...grid[row][col], isMine: true };\n+        updateAdjacentCounts(grid, row, col);\n+        minesPlaced++;\n+      }\n+    }\n+  }\n+\n+  // Update the adjacent mine count for cells surrounding a new mine\n+  function updateAdjacentCounts(grid, row, col) {\n+    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n+      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n+        if (!grid[r][c].isMine) {\n+          grid[r][c].adjacentMines++;\n+        }\n+      }\n+    }\n+  }\n+\n+  // Handle left-click on a cell\n+  function handleClick(row, col) {\n+    if (isGameOver || grid[row][col].isRevealed) return;\n+\n+    const newGrid = [...grid];\n+\n+    // Place mines on first click, avoiding the clicked cell\n+    if (isFirstClick) {\n+      placeMinesAvoidingFirstClick(newGrid, row, col);\n+      setIsFirstClick(false);\n+    }\n+\n+    // Check if the cell is a mine\n+    if (newGrid[row][col].isMine) {\n+      setIsGameOver(true);\n+      alert(\"Game over! You hit a bomb!\");\n+      revealAllMines(newGrid);\n+      setGrid(newGrid);\n+      return;\n+    }\n+\n+    // Reveal the cell and adjacent cells if no adjacent mines\n+    revealCell(newGrid, row, col);\n+    setGrid(newGrid);\n+\n+    // Check if the player has won\n+    if (checkWin(newGrid)) {\n+      setHasWon(true);\n+      alert(\"Congratulations! You won!\");\n+    }\n+  }\n+\n+  // Right-click or shift-click to toggle a flag\n+  function handleRightClick(event, row, col) {\n+    event.preventDefault();\n+    if (isGameOver || grid[row][col].isRevealed) return;\n+\n+    const newGrid = [...grid];\n+    newGrid[row][col].isFlagged = !newGrid[row][col].isFlagged;\n+    setFlagCount(flagCount + (newGrid[row][col].isFlagged ? -1 : 1));\n+    setGrid(newGrid);\n+  }\n+\n+  // Reveal a cell and, if no adjacent mines, reveal neighboring cells recursively\n+  function revealCell(grid, row, col) {\n+    if (\n+      row < 0 || col < 0 || row >= config.size || col >= config.size || \n+      grid[row][col].isRevealed || grid[row][col].isMine\n+    ) return;\n+\n+    grid[row][col].isRevealed = true;\n+\n+    if (grid[row][col].adjacentMines === 0) {\n+      getNeighbors(row, col).forEach(([r, c]) => revealCell(grid, r, c));\n+    }\n+  }\n+\n+  // Get all valid neighboring cells for a given cell\n+  function getNeighbors(row, col) {\n+    const directions = [\n+      [-1, -1], [-1, 0], [-1, 1],\n+      [0, -1],           [0, 1],\n+      [1, -1], [1, 0], [1, 1]\n+    ];\n+    return directions\n+      .map(([dr, dc]) => [row + dr, col + dc])\n+      .filter(([r, c]) => r >= 0 && r < config.size && c >= 0 && c < config.size);\n+  }\n+\n+  // Show all mines if the game is over\n+  function revealAllMines(grid) {\n+    grid.forEach(row => {\n+      row.forEach(cell => {\n+        if (cell.isMine) {\n+          cell.isRevealed = true;\n+        }\n+      });\n+    });\n+  }\n+\n+  // Check if the player has won by revealing all non-mine cells\n+  function checkWin(grid) {\n+    return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n+  }\n+\n+  // Reset the game state and initialize a new grid\n+  function resetGame() {\n+    setIsGameOver(false);\n+    setHasWon(false);\n+    setIsFirstClick(true);\n+    initializeGrid();\n+  }\n+\n+  // Render the Minesweeper game\n+  return (\n+    <div>\n+      <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n+      <h2>Flags remaining: {flagCount}</h2>\n+      <button onClick={resetGame}>Reset</button>\n+      <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n+        {grid.map((row, rIndex) =>\n+          row.map((cell, cIndex) => (\n+            <Cell\n+              key={`${rIndex}-${cIndex}`}\n+              isRevealed={cell.isRevealed}\n+              isMine={cell.isMine}\n+              adjacentMines={cell.adjacentMines}\n+              isFlagged={cell.isFlagged}\n+              onClick={() => handleClick(rIndex, cIndex)}\n+              onContextMenu={(e) => handleRightClick(e, rIndex, cIndex)}\n+            />\n+          ))\n+        )}\n+      </div>\n+    </div>\n+  );\n+}\n+\n+export default Game;\n"
                },
                {
                    "date": 1731365845689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,36 +18,30 @@\n     medium: { size: 16, mines: 40 },\n     hard: { size: 30, mines: 99 },\n   }[difficulty] || { size: 8, mines: 10 };\n \n-  // Reset the game whenever the difficulty changes\n+  // Load saved game state if available on component mount\n   useEffect(() => {\n-    resetGame();\n-  }, [difficulty]);\n-\n-  // Load saved game state if available\n-  useEffect(() => {\n     const savedState = JSON.parse(localStorage.getItem(\"minesweeperGameState\"));\n     if (savedState && savedState.difficulty === difficulty) {\n       setGrid(savedState.grid);\n       setIsGameOver(savedState.isGameOver);\n       setHasWon(savedState.hasWon);\n       setIsFirstClick(savedState.isFirstClick);\n       setFlagCount(savedState.flagCount);\n     } else {\n-      resetGame();\n+      resetGame(); // No saved state or different difficulty, start fresh\n     }\n   }, [difficulty]);\n \n-  // Save game state to local storage on state changes\n+  // Save game state to localStorage on relevant state changes\n   useEffect(() => {\n     const gameState = { grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty };\n     localStorage.setItem(\"minesweeperGameState\", JSON.stringify(gameState));\n   }, [grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty]);\n \n   // Initialize a new grid and set up mines\n   function initializeGrid() {\n-    // Create an empty grid with no mines and cells not revealed\n     const emptyGrid = Array.from({ length: config.size }, () =>\n       Array.from({ length: config.size }, () => ({\n         isRevealed: false,\n         isMine: false,\n@@ -66,12 +60,9 @@\n     while (minesPlaced < config.mines) {\n       const row = Math.floor(Math.random() * config.size);\n       const col = Math.floor(Math.random() * config.size);\n \n-      if (\n-        (row !== firstRow || col !== firstCol) &&\n-        !grid[row][col].isMine\n-      ) {\n+      if ((row !== firstRow || col !== firstCol) && !grid[row][col].isMine) {\n         grid[row][col] = { ...grid[row][col], isMine: true };\n         updateAdjacentCounts(grid, row, col);\n         minesPlaced++;\n       }\n@@ -133,12 +124,9 @@\n   }\n \n   // Reveal a cell and, if no adjacent mines, reveal neighboring cells recursively\n   function revealCell(grid, row, col) {\n-    if (\n-      row < 0 || col < 0 || row >= config.size || col >= config.size || \n-      grid[row][col].isRevealed || grid[row][col].isMine\n-    ) return;\n+    if (row < 0 || col < 0 || row >= config.size || col >= config.size || grid[row][col].isRevealed || grid[row][col].isMine) return;\n \n     grid[row][col].isRevealed = true;\n \n     if (grid[row][col].adjacentMines === 0) {\n@@ -207,165 +195,4 @@\n   );\n }\n \n export default Game;\n-import React, { useState, useEffect } from 'react';\n-import { useParams } from 'react-router-dom';\n-import Cell from '../components/Cell';\n-\n-function Game() {\n-  const { difficulty } = useParams();\n-  const [grid, setGrid] = useState([]);\n-  const [isGameOver, setIsGameOver] = useState(false);\n-  const [hasWon, setHasWon] = useState(false);\n-\n-  // Sets up the size of the grid and the number of mines based on the selected difficulty level\n-  const config = {\n-    easy: { size: 8, mines: 10 },\n-    medium: { size: 16, mines: 40 },\n-    hard: { size: 30, mines: 99 },\n-  }[difficulty] || { size: 8, mines: 10 }; // Default to easy if something goes wrong\n-\n-  // Reset the game every time the difficulty changes\n-  useEffect(() => {\n-    resetGame();\n-  }, [difficulty]);\n-\n-  // Sets up a new grid and adds mines\n-  function initializeGrid() {\n-    // Create a blank grid with cells set to \"not revealed\" and no mines\n-    const emptyGrid = Array.from({ length: config.size }, () =>\n-      Array.from({ length: config.size }, () => ({\n-        isRevealed: false,\n-        isMine: false,\n-        adjacentMines: 0,\n-      }))\n-    );\n-\n-    // Add mines to the grid\n-    placeMines(emptyGrid);\n-    setGrid(emptyGrid);\n-  }\n-\n-  // Randomly add mines to cells in the grid\n-  function placeMines(grid) {\n-    let minesPlaced = 0;\n-    while (minesPlaced < config.mines) {\n-      const row = Math.floor(Math.random() * config.size);\n-      const col = Math.floor(Math.random() * config.size);\n-\n-      // Only place a mine if there's not already one there\n-      if (!grid[row][col].isMine) {\n-        grid[row][col] = { ...grid[row][col], isMine: true };\n-        updateAdjacentCounts(grid, row, col); // Update nearby cells to track this new mine\n-        minesPlaced++;\n-      }\n-    }\n-  }\n-\n-  // Increments the \"adjacentMines\" count for cells around a newly placed mine\n-  function updateAdjacentCounts(grid, row, col) {\n-    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n-      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n-        if (!grid[r][c].isMine) {\n-          grid[r][c].adjacentMines++;\n-        }\n-      }\n-    }\n-  }\n-\n-  // Handles what happens when a player clicks a cell\n-  function handleClick(row, col) {\n-    // Do nothing if the game is already over or if the cell is already revealed\n-    if (isGameOver || grid[row][col].isRevealed) return;\n-\n-    const newGrid = [...grid];\n-\n-    // If the cell is a mine, game over!\n-    if (newGrid[row][col].isMine) {\n-      setIsGameOver(true);\n-      alert(\"Game over! You hit a bomb!\");\n-      revealAllMines(newGrid); // Show all mines\n-      setGrid(newGrid);\n-      return;\n-    }\n-\n-    // If it's safe, start revealing cells recursively\n-    revealCell(newGrid, row, col);\n-    setGrid(newGrid);\n-\n-    // Check if all non-mine cells are revealed, meaning the player wins\n-    if (checkWin(newGrid)) {\n-      setHasWon(true);\n-      alert(\"Congratulations! You won!\");\n-    }\n-  }\n-\n-  // Recursive function to reveal cells with 0 adjacent mines\n-  function revealCell(grid, row, col) {\n-    if (\n-      row < 0 || col < 0 || row >= config.size || col >= config.size || \n-      grid[row][col].isRevealed || grid[row][col].isMine\n-    ) {\n-      return; // Stop if out of bounds, already revealed, or a mine\n-    }\n-\n-    grid[row][col].isRevealed = true;\n-\n-    // If the cell has no adjacent mines, keep revealing nearby cells\n-    if (grid[row][col].adjacentMines === 0) {\n-      revealCell(grid, row - 1, col);\n-      revealCell(grid, row + 1, col);\n-      revealCell(grid, row, col - 1);\n-      revealCell(grid, row, col + 1);\n-      revealCell(grid, row - 1, col - 1);\n-      revealCell(grid, row - 1, col + 1);\n-      revealCell(grid, row + 1, col - 1);\n-      revealCell(grid, row + 1, col + 1);\n-    }\n-  }\n-\n-  // Shows all mines when the game is over\n-  function revealAllMines(grid) {\n-    grid.forEach(row => {\n-      row.forEach(cell => {\n-        if (cell.isMine) {\n-          cell.isRevealed = true;\n-        }\n-      });\n-    });\n-  }\n-\n-  // Checks if the player has revealed all non-mine cells\n-  function checkWin(grid) {\n-    return grid.flat().every(cell => cell.isMine || cell.isRevealed);\n-  }\n-\n-  // Resets the game by reinitializing the grid and resetting the game state\n-  function resetGame() {\n-    setIsGameOver(false);\n-    setHasWon(false);\n-    initializeGrid();\n-  }\n-\n-  return (\n-    <div>\n-      <h1>{isGameOver ? \"Game Over\" : hasWon ? \"You Won!\" : \"Minesweeper\"}</h1>\n-      <button onClick={resetGame}>Reset</button>\n-      <div className=\"board\" style={{ gridTemplateColumns: `repeat(${config.size}, 1fr)` }}>\n-        {grid.map((row, rIndex) =>\n-          row.map((cell, cIndex) => (\n-            <Cell\n-              key={`${rIndex}-${cIndex}`}\n-              isRevealed={cell.isRevealed}\n-              isMine={cell.isMine}\n-              adjacentMines={cell.adjacentMines}\n-              onClick={() => handleClick(rIndex, cIndex)}\n-            />\n-          ))\n-        )}\n-      </div>\n-    </div>\n-  );\n-}\n-\n-export default Game;\n"
                },
                {
                    "date": 1731369222494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,28 +18,13 @@\n     medium: { size: 16, mines: 40 },\n     hard: { size: 30, mines: 99 },\n   }[difficulty] || { size: 8, mines: 10 };\n \n-  // Load saved game state if available on component mount\n+  // Reset the game when the component mounts or the difficulty changes\n   useEffect(() => {\n-    const savedState = JSON.parse(localStorage.getItem(\"minesweeperGameState\"));\n-    if (savedState && savedState.difficulty === difficulty) {\n-      setGrid(savedState.grid);\n-      setIsGameOver(savedState.isGameOver);\n-      setHasWon(savedState.hasWon);\n-      setIsFirstClick(savedState.isFirstClick);\n-      setFlagCount(savedState.flagCount);\n-    } else {\n-      resetGame(); // No saved state or different difficulty, start fresh\n-    }\n+    resetGame(); // Initialize game state\n   }, [difficulty]);\n \n-  // Save game state to localStorage on relevant state changes\n-  useEffect(() => {\n-    const gameState = { grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty };\n-    localStorage.setItem(\"minesweeperGameState\", JSON.stringify(gameState));\n-  }, [grid, isGameOver, hasWon, isFirstClick, flagCount, difficulty]);\n-\n   // Initialize a new grid and set up mines\n   function initializeGrid() {\n     const emptyGrid = Array.from({ length: config.size }, () =>\n       Array.from({ length: config.size }, () => ({\n@@ -48,11 +33,10 @@\n         isFlagged: false,\n         adjacentMines: 0,\n       }))\n     );\n-\n-    setGrid(emptyGrid);\n-    setFlagCount(config.mines);\n+    setGrid(emptyGrid); // Set grid to the initial empty grid\n+    setFlagCount(config.mines); // Initialize flag count based on mines\n   }\n \n   // Place mines on the grid, avoiding the first click position\n   function placeMinesAvoidingFirstClick(grid, firstRow, firstCol) {\n@@ -79,9 +63,9 @@\n       }\n     }\n   }\n \n-  // Handle left-click on a cell\n+  // Handle left-click on a cell, with Safe First Turn logic\n   function handleClick(row, col) {\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n     const newGrid = [...grid];\n@@ -111,9 +95,9 @@\n       alert(\"Congratulations! You won!\");\n     }\n   }\n \n-  // Right-click or shift-click to toggle a flag\n+  // Right-click or shift-click to toggle a flag, implementing the Flag Bomb Function\n   function handleRightClick(event, row, col) {\n     event.preventDefault();\n     if (isGameOver || grid[row][col].isRevealed) return;\n \n@@ -122,9 +106,9 @@\n     setFlagCount(flagCount + (newGrid[row][col].isFlagged ? -1 : 1));\n     setGrid(newGrid);\n   }\n \n-  // Reveal a cell and, if no adjacent mines, reveal neighboring cells recursively\n+  // Reveal a cell and, if no adjacent mines, implement Auto Clear by recursively revealing cells\n   function revealCell(grid, row, col) {\n     if (row < 0 || col < 0 || row >= config.size || col >= config.size || grid[row][col].isRevealed || grid[row][col].isMine) return;\n \n     grid[row][col].isRevealed = true;\n@@ -166,9 +150,9 @@\n   function resetGame() {\n     setIsGameOver(false);\n     setHasWon(false);\n     setIsFirstClick(true);\n-    initializeGrid();\n+    initializeGrid(); // This will set up an empty grid initially\n   }\n \n   // Render the Minesweeper game\n   return (\n"
                }
            ],
            "date": 1731359246990,
            "name": "Commit-0",
            "content": "import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport Cell from '../components/Cell';\n\nfunction Game() {\n  const { difficulty } = useParams();\n  const [grid, setGrid] = useState([]);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [hasWon, setHasWon] = useState(false);\n\n  const config = {\n    easy: { size: 8, mines: 10 },\n    medium: { size: 16, mines: 40 },\n    hard: { size: 30, mines: 99 },\n  }[difficulty] || { size: 8, mines: 10 };\n\n  useEffect(() => {\n    resetGame();\n  }, [difficulty]);\n\n  function initializeGrid() {\n    const emptyGrid = Array(config.size).fill(null).map(() => Array(config.size).fill({\n      isRevealed: false, isMine: false, adjacentMines: 0,\n    }));\n\n    placeMines(emptyGrid);\n    setGrid(emptyGrid);\n  }\n\n  function placeMines(grid) {\n    let minesPlaced = 0;\n    while (minesPlaced < config.mines) {\n      const row = Math.floor(Math.random() * config.size);\n      const col = Math.floor(Math.random() * config.size);\n      if (!grid[row][col].isMine) {\n        grid[row][col].isMine = true;\n        updateAdjacentCounts(grid, row, col);\n        minesPlaced++;\n      }\n    }\n  }\n\n  function updateAdjacentCounts(grid, row, col) {\n    for (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, config.size - 1); r++) {\n      for (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, config.size - 1); c++) {\n        if (!grid[r][c].isMine) {\n          grid[r][c].adjacentMines++;\n        }\n      }\n    }\n  }\n\n  function handleClick(row, col) {\n    if (isGameOver || grid[row][col].isRevealed) return;\n\n    if (grid[row][col].isMine) {\n      setIsGameOver(true);\n      alert(\"Game over! You lost!\");\n      return;\n    }\n\n    const newGrid = [...grid];\n    newGrid[row][col].isRevealed = true;\n    setGrid(newGrid);\n\n    if (checkWin(newGrid)) {\n      setHasWon(true);\n      alert(\"Game over! You won!\");\n    }\n  }\n\n  function checkWin(grid) {\n    return grid.flat().every(cell => (cell.isMine || cell.isRevealed));\n  }\n\n  function resetGame() {\n    setIsGameOver(false);\n    setHasWon(false);\n    initializeGrid();\n  }\n\n  return (\n    <div>\n      <h1>{hasWon ? \"Game over! You Won!\" : isGameOver ? \"Game over! You lost!\" : \"Minesweeper\"}</h1>\n      <button onClick={resetGame}>Reset</button>\n      <div className=\"board\">\n        {grid.map((row, rIndex) => (\n          <div key={rIndex} className=\"row\">\n            {row.map((cell, cIndex) => (\n              <Cell\n                key={`${rIndex}-${cIndex}`}\n                isRevealed={cell.isRevealed}\n                isMine={cell.isMine}\n                adjacentMines={cell.adjacentMines}\n                onClick={() => handleClick(rIndex, cIndex)}\n              />\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default Game;\n"
        }
    ]
}